/// <reference lib="webworker" />
/* eslint-disable no-restricted-globals */

// This service worker can be customized!
// See https://developers.google.com/web/tools/workbox/modules
// for the list of available Workbox modules, or add any other
// code you'd like.
// You can also remove this file if you'd prefer not to use a
// service worker, and the Workbox build step will be skipped.

import type { Attribute } from '@alef/common';
import type { WorkboxPlugin } from 'workbox-core';
import { ExpirationPlugin } from 'workbox-expiration';
import { cleanupOutdatedCaches, createHandlerBoundToURL, precacheAndRoute } from 'workbox-precaching';
import { NavigationRoute, registerRoute } from 'workbox-routing';
import { NetworkFirst, StaleWhileRevalidate } from 'workbox-strategies';

declare const self: ServiceWorkerGlobalScope;

// auto-update on ready
// self.skipWaiting();
// clientsClaim();

cleanupOutdatedCaches();

// Precache all of the assets generated by your build process.
// Their URLs are injected into the manifest variable below.
// This variable must be present somewhere in your service worker file,
// even if you decide not to use precaching. See https://cra.link/PWA
precacheAndRoute(self.__WB_MANIFEST);

registerRoute(new NavigationRoute(createHandlerBoundToURL('/index.html')));

const fallbackToOfflineCachePlugin: WorkboxPlugin = {
	handlerDidError: async ({ request }: { request: Request }) => {
		const fallbackResponse = await caches.match(request, { cacheName: 'offline-requirements' });
		if (fallbackResponse) {
			return fallbackResponse;
		}
	},
};

// Cache model files as they are fetched
const modelPathMatch = /\/furniture\/.+\/model$/;
registerRoute(
	// Add in any other file extensions or routing criteria as needed.
	({ url }) => url.origin === import.meta.env.VITE_PUBLIC_API_ORIGIN && modelPathMatch.test(url.pathname),
	new StaleWhileRevalidate({
		cacheName: 'models',
		plugins: [
			// Ensure that once this runtime cache reaches a maximum size the
			// least-recently used files are removed.
			new ExpirationPlugin({ maxEntries: 800 }),
			fallbackToOfflineCachePlugin,
		],
	})
);

registerRoute(
	({ url }) => url.origin === import.meta.env.VITE_PUBLIC_API_ORIGIN && (url.pathname.endsWith('.jpg') || url.pathname.endsWith('.jpeg') || url.pathname.endsWith('.png')),
	new StaleWhileRevalidate({
		cacheName: 'images',
		plugins: [new ExpirationPlugin({ maxEntries: 200 }), fallbackToOfflineCachePlugin],
	})
);

// route API requests needed for offline mode to a special cache,
// some of which are prepopulated on install below.
// Other offline requirement queries can be added here.
registerRoute(
	({ url }) => {
		if (url.origin !== import.meta.env.VITE_PUBLIC_API_ORIGIN) {
			return false;
		}
		// offline furniture core query
		if (url.pathname === '/furniture' && url.searchParams.has('attribute') && url.searchParams.get('attribute') === 'package:core') {
			return true;
		}

		if (url.pathname === '/devices/self') {
			return true;
		}

		if (url.pathname === '/users/me') {
			return true;
		}

		if (url.pathname.startsWith('/properties')) {
			return true;
		}

		return false;
	},
	// try network first if available -- we only want cached versions
	// when we're really offline.
	new NetworkFirst({
		cacheName: 'offline-requirements',
		plugins: [new ExpirationPlugin({ maxEntries: 50 })],
	})
);

/**
 * On load, preload all 'starter pack' furniture into a special cache if not already
 * present.
 */
self.addEventListener('install', (event) => {
	event.waitUntil(
		caches.open('offline-requirements').then(async (cache) => {
			// precache this query too
			await cache.add(`${import.meta.env.VITE_PUBLIC_API_ORIGIN}/furniture?${new URLSearchParams({ attribute: `package:core` })}`);
			const coreFurniture = await fetch(
				`${import.meta.env.VITE_PUBLIC_API_ORIGIN}/furniture?${new URLSearchParams({
					attribute: `package:core`,
					pageSize: '1000',
				})}`
			);

			if (!coreFurniture.ok) {
				console.error('Failed to fetch core furniture metadata', coreFurniture);
				throw new Error('Failed to fetch core furniture metadata');
			}
			const coreFurnitureJson = (await coreFurniture.json()) as {
				id: string;
				name: string;
				attributes: Attribute[];
				modelUpdatedAt: string;
			}[];

			// avoid re-fetching the same furniture
			const cachedFurniture = await cache.keys();
			const cachedFurnitureIds = cachedFurniture.map((r) => r.url.split('/')[4]);
			const coreFurnitureJsonFiltered = coreFurnitureJson.filter((f) => !cachedFurnitureIds.includes(f.id));

			// Cache all original quality models and preview thumbnails
			const coreFurnitureModels = coreFurnitureJsonFiltered
				.map((f) => {
					return [`${import.meta.env.VITE_PUBLIC_API_ORIGIN}/furniture/${f.id}/model?quality=original`, `${import.meta.env.VITE_PUBLIC_API_ORIGIN}/furniture/${f.id}/image.jpg`];
				})
				.flat();
			await cache.addAll(coreFurnitureModels);
			console.log('Cached core furniture models', coreFurnitureModels);
		})
	);
});

// This allows the web app to trigger skipWaiting via
// registration.waiting.postMessage({type: 'SKIP_WAITING'})
self.addEventListener('message', (event) => {
	if (event.data && event.data.type === 'SKIP_WAITING') {
		console.log('Skip waiting');
		self.skipWaiting();
	}
});
